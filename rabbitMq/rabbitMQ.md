## 系统为什么使用消息中间件
- 系统解耦
- 异步调用
- 流量削峰

## 消息中间件的缺点
- 系统可用性降低
引入MQ会增加依赖，一旦MQ宕机则整合服务瘫痪
- 系统稳定性降低
MQ重发或者少发会产生脏数据，影响用户体验 
- 分布式一致性问题
假如一个业务涉及到多个服务，其中一个服务处理完成后发送消息到下一个服务，假设第二个服务成功接收到消息但是操作失败了，
这种情况造成数据不一致


## 高并发下如何保证生产者投递到消息中间件的消息不丢失
下面的图展示了这个问题

![](https://user-gold-cdn.xitu.io/2019/1/14/1684cd960df644b1?imageslim)

- ####confirm机制
1. 生产端开启confirm模式，接着投递消息，如果MQ一旦将消息持久到磁盘后必须回传一个confirm消息给生产端
2. 开启confirm模式后消息投递时会附带一个delivery tag，消息投递成功后依据返回的tag来确定是否删除这条消息，
delivery tag是跟着channel走的，其唯一性只能在一个channel中保证
3. 消费端如果内部发生错误则返回nack，针对这种情况可以选择重新投放消息
4. 如果长时间没有返回ack/nack有可能是在传输过程中丢失了，这种情况也可以选择重新投放

![](https://user-gold-cdn.xitu.io/2019/1/14/1684cda953f52ec9?imageslim)


- ####confirm机制投递消息会有高延迟性
1. rabbitMQ的消息会先驻留在内存中，会隔几百毫秒将多个消息持久化到磁盘中，需要等持久化技术之后才能接收ack消息

- ####高并发下如何投递才能不丢失
**面临的问题**
1. 为等待ack，消息需要临时存储，但是不能放在内存中，高并发下会出现内存益处情况
2. 不能以同步写消息+等待ack的方式投递，这种方式会导致消息同步阻塞，降低性能和吞吐量

**解决方式**
1. 使用kv存储消息
2. 投递消息后等待ack使用异步，消息投递出去之后该线程就可以返回了，通过channel注册一个confirm监听器实现异步回调，收到ack消息后删除该消息，收到nack则重发