### 集合
- **扩容机制**</br>
以jdk1.8为例
arrayList 线性表存储 默认开辟大小为10的空间，当默认空间不够的时候则以原数组的长度的1.5倍(不是每次都是完整的1.5倍)进行扩增
原理：当向arrayList中添加一个变量的时候，会在当前size + 1作为新增后size长度，之后取新的size和list空间长度中的最大值。期间modCount(记录集合操作次数的参数)
会递增一次，如果出现新增后的size大于当前空间长度会出发grow函数进行扩容，新的长度 = 旧空间长度 + 旧空间长度 >> 1， 如果计算出来的新长度小于新增后的长度的话会直接把新增后的长度赋值给新长度
之后会把原先集合中的数据拷贝到新集合中，集合长度为新的长度。捎带一提，arrayList的长度不会超过 Int的最大值(2147483647) 因为数组需要8字节取存储自己的大小所以实际会 -8

### 线程thread中start和run的区别
start():<br/>
他的作用是启动一个新的线程，通过start()方法来启动一个新的线程，出于就绪(可运行)状态，并没有运行，一旦得到cpu时间片就会执行相应线程的run()方法。这里方法run()称为线程体，它包含了这个这个线程的内容，
run()方法运行结束此线程随即终止。start()不能被重复调用，用start()方法来启动线程真正实现来多线程运行即无需等待某个线程的run方法体代码执行结束就直接执行下面的代码。这里无需等待run方法执行完毕即可
执行下面的代码即进行了线程切换<br/>

run():<br/>
run()方法就和普通的成员方法一样，可以被重复调用。
如果直接调用run方法并不会启动新的线程，线程中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法执行完毕后才能继续执行下面的代码，这样就没达到多线程的目的。<br/>

总结针对Thread类中start和run方法的区别:<br/>
- start是新创建一个线程，不可能重复调用。run没有创建新的线程，是thread类中的一个普通的方法可以重复调用
- start中的run代码不执行完就可以执行后面部分代码，run必须等到其代码全部执行才能执行下面的代码
- start实现了多线程，run没有实现多线程







